/* 
  This file was generated automatically with ./scripts/maple2c.pl.
  Do not edit this file directly as it can be overwritten!!

  This Source Code Form is subject to the terms of the Mozilla Public
  License, v. 2.0. If a copy of the MPL was not distributed with this
  file, You can obtain one at http://mozilla.org/MPL/2.0/.

  Maple version     : Maple 2016 (X86 64 LINUX)
  Maple source      : ./maple/lda_exc/lda_xc_zlp.mpl
  Type of functional: lda_exc
*/

#define maple2c_order 4
#define MAPLE2C_FLAGS (XC_FLAGS_I_HAVE_EXC | XC_FLAGS_I_HAVE_VXC | XC_FLAGS_I_HAVE_FXC | XC_FLAGS_I_HAVE_KXC | XC_FLAGS_I_HAVE_LXC)


static inline void
func_unpol(const xc_func_type *p, int order, const double *rho , double *zk LDA_OUT_PARAMS_NO_EXC(XC_COMMA double *, ))
{

#ifndef XC_DONT_COMPILE_EXC
  double t1, t3, t5, t6, t7, t10, t11;

#ifndef XC_DONT_COMPILE_VXC
  double t14, t16, t18, t19, t22;

#ifndef XC_DONT_COMPILE_FXC
  double t24, t29, t35, t36, t41, t44;

#ifndef XC_DONT_COMPILE_KXC
  double t46, t53, t63, t65, t67, t68, t72, t75;

#ifndef XC_DONT_COMPILE_LXC
  double t86, t102;
#endif

#endif

#endif

#endif

#endif


  lda_xc_zlp_params *params;

  assert(p->params != NULL);
  params = (lda_xc_zlp_params * )(p->params);

  t1 = POW_1_3(rho[0]);
  t3 = 0.1e1 / params->zlp_k;
  t5 = 0.1e1 + 0.1e1 / t1 * t3;
  t6 = log(t5);
  t7 = params->zlp_k * t6;
  t10 = params->zlp_a0 * (-t7 * t1 + 0.1e1);
  t11 = t10 * t1;
  if(zk != NULL && (p->info->flags & XC_FLAGS_HAVE_EXC))
    zk[0] = -t11;

#ifndef XC_DONT_COMPILE_VXC

  if(order < 1) return;


  t14 = t1 * rho[0] * params->zlp_a0;
  t16 = 0.1e1 / t5;
  t18 = t1 * t1;
  t19 = 0.1e1 / t18;
  t22 = 0.1e1 / rho[0] * t16 / 0.3e1 - t7 * t19 / 0.3e1;
  if(vrho != NULL && (p->info->flags & XC_FLAGS_HAVE_VXC))
    vrho[0] = -0.4e1 / 0.3e1 * t11 - t14 * t22;

#ifndef XC_DONT_COMPILE_FXC

  if(order < 2) return;


  t24 = params->zlp_a0 * t22;
  t29 = rho[0] * rho[0];
  t35 = t5 * t5;
  t36 = 0.1e1 / t35;
  t41 = 0.1e1 / t18 / rho[0];
  t44 = -0.2e1 / 0.9e1 / t29 * t16 + 0.1e1 / t1 / t29 * t36 * t3 / 0.9e1 + 0.2e1 / 0.9e1 * t7 * t41;
  if(v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    v2rho2[0] = -0.8e1 / 0.3e1 * t24 * t1 - 0.4e1 / 0.9e1 * t10 * t19 - t14 * t44;

#ifndef XC_DONT_COMPILE_KXC

  if(order < 3) return;


  t46 = params->zlp_a0 * t44;
  t53 = t29 * rho[0];
  t63 = 0.1e1 / t18 / t53;
  t65 = 0.1e1 / t35 / t5;
  t67 = params->zlp_k * params->zlp_k;
  t68 = 0.1e1 / t67;
  t72 = 0.1e1 / t18 / t29;
  t75 = 0.10e2 / 0.27e2 / t53 * t16 - 0.1e1 / t1 / t53 * t36 * t3 / 0.3e1 + 0.2e1 / 0.27e2 * t63 * t65 * t68 - 0.10e2 / 0.27e2 * t7 * t72;
  if(v3rho3 != NULL && (p->info->flags & XC_FLAGS_HAVE_KXC))
    v3rho3[0] = -0.4e1 * t46 * t1 - 0.4e1 / 0.3e1 * t24 * t19 + 0.8e1 / 0.27e2 * t10 * t41 - t14 * t75;

#ifndef XC_DONT_COMPILE_LXC

  if(order < 4) return;


  t86 = t29 * t29;
  t102 = t35 * t35;
  if(v4rho4 != NULL && (p->info->flags & XC_FLAGS_HAVE_LXC))
    v4rho4[0] = -0.16e2 / 0.3e1 * params->zlp_a0 * t75 * t1 - 0.8e1 / 0.3e1 * t46 * t19 + 0.32e2 / 0.27e2 * t24 * t41 - 0.40e2 / 0.81e2 * t10 * t72 - t14 * (-0.80e2 / 0.81e2 / t86 * t16 + 0.100e3 / 0.81e2 / t1 / t86 * t36 * t3 - 0.40e2 / 0.81e2 / t18 / t86 * t65 * t68 + 0.2e1 / 0.27e2 / t86 / rho[0] / t102 / t67 / params->zlp_k + 0.80e2 / 0.81e2 * t7 * t63);

#ifndef XC_DONT_COMPILE_MXC

  if(order < 5) return;


#endif

#endif

#endif

#endif

#endif


}


static inline void
func_pol(const xc_func_type *p, int order, const double *rho , double *zk LDA_OUT_PARAMS_NO_EXC(XC_COMMA double *, ))
{

#ifndef XC_DONT_COMPILE_EXC
  double t1, t2, t4, t6, t7, t8, t11, t12;

#ifndef XC_DONT_COMPILE_VXC
  double t15, t17, t19, t20, t23;

#ifndef XC_DONT_COMPILE_FXC
  double t25, t30, t36, t37, t42, t45;

#ifndef XC_DONT_COMPILE_KXC
  double t47, t54, t64, t66, t68, t69, t73, t76;

#ifndef XC_DONT_COMPILE_LXC
  double t87, t103;
#endif

#endif

#endif

#endif

#endif


  lda_xc_zlp_params *params;

  assert(p->params != NULL);
  params = (lda_xc_zlp_params * )(p->params);

  t1 = rho[0] + rho[1];
  t2 = POW_1_3(t1);
  t4 = 0.1e1 / params->zlp_k;
  t6 = 0.1e1 + 0.1e1 / t2 * t4;
  t7 = log(t6);
  t8 = params->zlp_k * t7;
  t11 = params->zlp_a0 * (-t8 * t2 + 0.1e1);
  t12 = t11 * t2;
  if(zk != NULL && (p->info->flags & XC_FLAGS_HAVE_EXC))
    zk[0] = -t12;

#ifndef XC_DONT_COMPILE_VXC

  if(order < 1) return;


  t15 = t2 * t1 * params->zlp_a0;
  t17 = 0.1e1 / t6;
  t19 = t2 * t2;
  t20 = 0.1e1 / t19;
  t23 = 0.1e1 / t1 * t17 / 0.3e1 - t8 * t20 / 0.3e1;
  if(vrho != NULL && (p->info->flags & XC_FLAGS_HAVE_VXC))
    vrho[0] = -0.4e1 / 0.3e1 * t12 - t15 * t23;

  if(vrho != NULL && (p->info->flags & XC_FLAGS_HAVE_VXC))
    vrho[1] = vrho[0];

#ifndef XC_DONT_COMPILE_FXC

  if(order < 2) return;


  t25 = params->zlp_a0 * t23;
  t30 = t1 * t1;
  t36 = t6 * t6;
  t37 = 0.1e1 / t36;
  t42 = 0.1e1 / t19 / t1;
  t45 = -0.2e1 / 0.9e1 / t30 * t17 + 0.1e1 / t2 / t30 * t37 * t4 / 0.9e1 + 0.2e1 / 0.9e1 * t8 * t42;
  if(v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    v2rho2[0] = -0.8e1 / 0.3e1 * t25 * t2 - 0.4e1 / 0.9e1 * t11 * t20 - t15 * t45;

  if(v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    v2rho2[1] = v2rho2[0];

  if(v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    v2rho2[2] = v2rho2[1];

#ifndef XC_DONT_COMPILE_KXC

  if(order < 3) return;


  t47 = params->zlp_a0 * t45;
  t54 = t30 * t1;
  t64 = 0.1e1 / t19 / t54;
  t66 = 0.1e1 / t36 / t6;
  t68 = params->zlp_k * params->zlp_k;
  t69 = 0.1e1 / t68;
  t73 = 0.1e1 / t19 / t30;
  t76 = 0.10e2 / 0.27e2 / t54 * t17 - 0.1e1 / t2 / t54 * t37 * t4 / 0.3e1 + 0.2e1 / 0.27e2 * t64 * t66 * t69 - 0.10e2 / 0.27e2 * t8 * t73;
  if(v3rho3 != NULL && (p->info->flags & XC_FLAGS_HAVE_KXC))
    v3rho3[0] = -0.4e1 * t47 * t2 - 0.4e1 / 0.3e1 * t25 * t20 + 0.8e1 / 0.27e2 * t11 * t42 - t15 * t76;

  if(v3rho3 != NULL && (p->info->flags & XC_FLAGS_HAVE_KXC))
    v3rho3[1] = v3rho3[0];

  if(v3rho3 != NULL && (p->info->flags & XC_FLAGS_HAVE_KXC))
    v3rho3[2] = v3rho3[1];

  if(v3rho3 != NULL && (p->info->flags & XC_FLAGS_HAVE_KXC))
    v3rho3[3] = v3rho3[2];

#ifndef XC_DONT_COMPILE_LXC

  if(order < 4) return;


  t87 = t30 * t30;
  t103 = t36 * t36;
  if(v4rho4 != NULL && (p->info->flags & XC_FLAGS_HAVE_LXC))
    v4rho4[0] = -0.16e2 / 0.3e1 * params->zlp_a0 * t76 * t2 - 0.8e1 / 0.3e1 * t47 * t20 + 0.32e2 / 0.27e2 * t25 * t42 - 0.40e2 / 0.81e2 * t11 * t73 - t15 * (-0.80e2 / 0.81e2 / t87 * t17 + 0.100e3 / 0.81e2 / t2 / t87 * t37 * t4 - 0.40e2 / 0.81e2 / t19 / t87 * t66 * t69 + 0.2e1 / 0.27e2 / t87 / t1 / t103 / t68 / params->zlp_k + 0.80e2 / 0.81e2 * t8 * t64);

  if(v4rho4 != NULL && (p->info->flags & XC_FLAGS_HAVE_LXC))
    v4rho4[1] = v4rho4[0];

  if(v4rho4 != NULL && (p->info->flags & XC_FLAGS_HAVE_LXC))
    v4rho4[2] = v4rho4[1];

  if(v4rho4 != NULL && (p->info->flags & XC_FLAGS_HAVE_LXC))
    v4rho4[3] = v4rho4[2];

  if(v4rho4 != NULL && (p->info->flags & XC_FLAGS_HAVE_LXC))
    v4rho4[4] = v4rho4[3];

#ifndef XC_DONT_COMPILE_MXC

  if(order < 5) return;


#endif

#endif

#endif

#endif

#endif


}

