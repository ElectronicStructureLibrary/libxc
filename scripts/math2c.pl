#!/usr/bin/env perl

my $srcdir     = $ARGV[0];
my $functional = $ARGV[1];
my $order      = $ARGV[2];

my $mathfile = "$srcdir/mathematica/functionals/$functional.m";

# Find out the type of functional
open my $in, '<', $mathfile or 
    die "File $srcdir/mathematica/functionals/$functional.m does not exist\n";

my $functype = "";
my $prefix   = "";
while($_ = <$in>){
  if(/^\(\* type:\s(\S*)\s/){
    $functype = $1;
  };
  if(/^\(\* prefix:/){
    while( ($_ = <$in>) && ! /^\*\)/ ){
      $prefix .= $_;
    }
  }
}
close($in);

open my $out, '>', "$srcdir/src/math2c/$functional.c" or 
    die "Could not open file $srcdir/math2c/$functional.c for writing\n";

print $out "/* 
  This file was generated automatically with $0.
  Do not edit this file directly as it can be overwritten!!

  Mathematica source: $mathfile
  Type of functional: $functype
*/
";

my %commands = (
        "work_lda"    => \&work_lda,
        "work_gga_x"  => \&work_gga_x,
    );

if ($commands{$functype}) {
  $commands{$functype}->();
} else {
  die "No such type: $string\n";
} 

sub math_replace {
  # The replacements have to be made in order, so
  # we can not use a hash table
  my @math_replace = (
    # variables and inner parameters
    "varrs"        , "r->rs[1]",
    "varzeta"      , "r->zeta",
    "params"       , "params->",

    # constants
    "Pi"           , "M_PI",
    "XFACTORC"     , "X_FACTOR_C",
    "MUGE"         , "MU_GE",

    # functions
    "Power.E,"     , "EXP(",
    "Power"        , "POW",
    "Sqrt"         , "SQRT",
    "Log"          , "LOG",
    "ArcSinh"      , "asinh",
    "Tanh"         , "TANH",
    "PolyLog.2,"   , "XC(dilogarithm)(",
    "ProductLOG."  , "XC(lambert_w)(",
  );
  my ($text) = @_;

  for(my $j=0; $j<$#math_replace; $j+=2){
    $text =~ s/$math_replace[$j]/$math_replace[$j+1]/g;
  }

  return $text;
}

sub math_work {
  my ($type, $info, $out, $order, $textorder) = @_;

  my $i = 0;
  foreach my $ninfo (@{$info}){
    return if($i > $order);
    print $out "\n    if($textorder >= $i){\n";
    foreach my $der (@{$ninfo}){
      my $der_type = shift(@{$der});
      my $orders   = join(" ", @{$der});
      my $math     = `math -script $srcdir/mathematica/$type.m $mathfile $orders`;
      print $out "      $der_type = ", math_replace($math), ";\n";
    }
    print $out "    }\n\n";
    $i++;
  }
}

sub work_lda(){
  $info_unpolarized = [
      [["r->zk", 0, -1]],
      [["r->dedz", -1, -1], ["r->dedrs", 1, -1]],
      [["r->d2edz2", -1, -1], ["r->d2edrsz", -1, -1], ["r->d2edrs2", 2, -1]],
      [["r->d3edz3", -1, -1], ["r->d3edrs2z", -1, -1], ["r->d3edrsz2", -1, -1], ["r->d3edrs3", 3, -1]]
      ];

  $info_polarized = [
      [["r->zk", 0, 0]],
      [["r->dedz", 0, 1], ["r->dedrs", 1, 0]],
      [["r->d2edz2", 0, 2], ["r->d2edrsz", 1, 1], ["r->d2edrs2", 2, 0]],
      [["r->d3edz3", 0, 3], ["r->d3edrs2z", 1, 2], ["r->d3edrsz2", 2, 1], ["r->d3edrs3", 3, 0]]
      ];

  print $out "
void XC(math2c_${functional}_func)
  (const XC(func_type) *p, XC(lda_work_t) *r)
{
$prefix

  if(p->nspin == XC_UNPOLARIZED){
";

  math_work("work_lda", $info_unpolarized, $out, $order, "r->order");

  print $out "  }else{\n";

  math_work("work_lda", $info_polarized, $out, $order, "r->order");

  print $out "  }\n}\n

#define math2c_order $order
#define math2c_func  XC(math2c_${functional}_func)
\n";

  close($out);
}


sub work_gga_x(){

  print $out "
void XC(math2c_${functional}_enhance)
  (const XC(func_type) *p, int order, 
   FLOAT x, FLOAT *f, FLOAT *dfdx, FLOAT *d2fdx2, FLOAT *d3fdx3)
{
$prefix
";

  my $info = [
    [["*f", 0]], [["*dfdx", 1]], [["*d2fdx2", 2]], [["*d3fdx3", 3]]
  ];

  math_work("work_gga_x", $info, $out, $order, "order");

  print $out "}\n

#define math2c_order $order
#define math2c_func  XC(math2c_${functional}_enhance)
\n";

  close($out);
}


